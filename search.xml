<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Vue2源码：源码速读]]></title>
      <url>%2F2017%2F05%2F12%2Fvue2%2FVue2-instance%2F</url>
      <content type="text"><![CDATA[基本思路: 首先通过模块依赖关系找到Vue类在哪定义 Vue类的属性及方法在哪个阶段定义的，理清添加的顺序及依赖关系 Vue实例化初始化方法的执行顺序，找到生命周期钩子在哪些对应方法中触发的 Vue实例化时，组件模板是如何渲染并更新到el上的 Vue实例，vm的Data响应式是怎么实现的 阅读源码全程忽略process.env.NODE_ENV !== &#39;production&#39;条件里的代码，先了解主流程 要理清命名的规则，便于理解每一步的作用 xxxMixin(Vue) – 给Vue类添加原型方法 initXxx(vm) – 给vm添加初始化属性 vm – 对应Vue的实例 内置私有方法或属性前加下划线_, 暴露给外部调用的方法或属性前加美元符号$ 我们可以查看组件的接口配置文件flow/component.js，基本上包含了一个组件的所有属性和方法。 从代码构建入手1. package.json从scripts属性可看到打包入口文件build/build.js12345&#123; ... "build": "node build/build.js" ...&#125; 可从main、module等属性获取对应的版本，竟然还有ts版，不知是否可用？1234"main": "dist/vue.runtime.common.js", // webpack1"module": "dist/vue.runtime.esm.js", // webpack2 or rollup"unpkg": "dist/vue.js", // 直接&lt;script&gt;引入vue文件"typings": "types/index.d.ts", // typescript版 具体进度未知？？？ 2. dist 构建后的文件存放目录查看README.md Explanation of Build Files UMD CommonJS ES Module Full vue.js vue.common.js vue.esm.js Runtime-only vue.runtime.js vue.runtime.common.js vue.runtime.esm.js Full (production) vue.min.js Runtime-only (production) vue.runtime.min.js 我们用vue-cli时，因为用了vue-loader，不需要compiler编译模板。同时使用了ES6的import/export管理模块依赖。所以webpack2构建时所依赖的vue，就是基于ES module规范的runtime版本：vue.runtime.esm.js。 3. build/config.js 项目构建配置文件dist目录下文件的rollup配置都在此文件中定义，其中vue.runtime.esm.js对应配置如下：123456'web-runtime-esm': &#123; entry: resolve('web/runtime.js'), dest: resolve('dist/vue.runtime.esm.js'), format: 'es', banner &#125;, 找到rollup入口文件web/runtime.js 4. build/alias.js通过别名快速定位文件依赖，就是webstorm不能ctrl+点击跳转了,有点坑1234567891011module.exports = &#123; vue: path.resolve(__dirname, '../src/platforms/web/runtime-with-compiler'), compiler: path.resolve(__dirname, '../src/compiler'), core: path.resolve(__dirname, '../src/core'), shared: path.resolve(__dirname, '../src/shared'), web: path.resolve(__dirname, '../src/platforms/web'), weex: path.resolve(__dirname, '../src/platforms/weex'), server: path.resolve(__dirname, '../src/server'), entries: path.resolve(__dirname, '../src/entries'), sfc: path.resolve(__dirname, '../src/sfc')&#125; 5. src/platforms/web/runtime.js 通过别名找到源文件，只有2行。。。6. src/platforms/web/runtime/index.js 这才是真身。。。vue启动方法$mount在此定义，挂载至el，该参数可以是string 或者 Element，如果是字符串就调用document.querySelector方法返回DOM 7. src/core/index.js 顺着import Vue from xxx我们一路来到了core目录8. src/core/instance/index.js终于见到你，还好我没放弃1234567function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue)) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options)&#125; Vue构造函数就是在此定义，内部执行初始化方法_init，该方法在initMixin中定义Vue.prototype._init先在内部执行一系列初始化方法12345678initLifecycle(vm)initEvents(vm)initRender(vm)callHook(vm, 'beforeCreate')initInjections(vm) // resolve injections before data/propsinitState(vm)initProvide(vm) // resolve provide after data/propscallHook(vm, 'created') 最后，当实例化参数有el时，自动挂载实例至此DOM元素。123if (vm.$options.el) &#123; vm.$mount(vm.$options.el)&#125; initLifecycle除了一般状态的初始化，包含一个特殊的判断：是否为抽象组件将当前vm挂载第一个非抽象的父组件抽象组件自身不会渲染一个 DOM 元素，也不会出现在父组件链中。内置抽象组件：keep-live, transition 几个在mountComponent用到的方法：1vm.$el = el renderMixin: _renderlifecycleMixin: _updateWatcher: Watcher initEvent 12345// init parent attached events const listeners = vm.$options._parentListeners if (listeners) &#123; updateComponentListeners(vm, listeners) &#125; 开始不明白为什么在这里要判断listeners，因为vm.$options._parentListeners是在initRender之后才能获得，好像永远没有这属性了后来发现在initInternalComponent 内部组件初始化时会用定义，内部组件为了达到优化的目的直接复制对象过去，跳过merge options。 initInternalComponent有一个条件就是_isComponent, 它又是在什么时候定义的呢先定义的组件vue.component =&gt; new Vue() =&gt; mountComponent =&gt; new Watcher =&gt; updateComponent =&gt; _render() =&gt; _update =&gt; path =&gt; createPatchFunction =&gt; createElm =&gt;createComponentInstanceForVnode = componentVNodeHooks =&gt; createComponent =&gt; i(vnode, false / hydrating /, parentElm, refElm);初始化vnode组件实例时vnode.componentInstance，返回的是new vnodeComponentOptions.Ctor(options)，Ctor它指向Vue.component定义组件时返回的Sub构造函数，通过Vue.extend拷贝继承Vue。所以，在实例化子组件时和实例化Vue很像。到这里vdom的内容也看了大半了,顺带来看了initGlobalAPI的核心API`initRender在实例上添加了2个方法，用于将渲染函数转换为vnode，内外部方法的区别只有最后一个参数，类型为boolean _c - createElement(vm, a, b, c, d, false) $createElement - createElement(vm, a, b, c, d, true)createElement 只是_createElement的一个包装，通过最后一个参数来控制normalizationType的值， normalizationType决定组件转换函数。[simple]NormalizeChildren() 9. src/core/global-api/index.js挂载各种方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue2源码：Virtual Dom]]></title>
      <url>%2F2017%2F05%2F07%2Fvue2%2FVue2-Virtual%20Dom%2F</url>
      <content type="text"><![CDATA[src/core/vdom/vnode.js123456789constructor ( tag?: string, data?: VNodeData, children?: ?Array&lt;VNode&gt;, text?: string, elm?: Node, context?: Component, componentOptions?: VNodeComponentOptions ) src/core/vdom/create-component.jscomponentOptions组件参数只在创建组件时才需传入，包含Ctor, propsData, listeners, tag, children12345const vnode = new VNode( `vue-component-$&#123;Ctor.cid&#125;$&#123;name ? `-$&#123;name&#125;` : ''&#125;`, data, undefined, undefined, undefined, context, &#123; Ctor, propsData, listeners, tag, children &#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git submodule 子模块的使用]]></title>
      <url>%2F2017%2F05%2F06%2Fsubmodule%2F</url>
      <content type="text"><![CDATA[git submodule 有时候我们将一个项目分成多个子模块去维护，但是又想要有一个清晰的项目包含关系就可以通过父子模块来实现。 比如我有一个nodejs学习的项目计划，包含很多个nodejs模块的学习，每一个小模块的demo都有自己独立的依赖包，为了方便写demo我将他们分为nodejs-xxx系列的小项目。他们分散在github的仓库列表里。为了可以清晰的查看他们，我们可以通过git子模块去管理他们。 基本上通过《Git-工具-子模块》这篇文章就可以掌握它的实现步骤。但是，关于子模块代码更新同步的地方没有讲清楚，这里写下我自己总结的步骤： 添加子模块 1$ git submodule add https://github.com/ICELI/nodejs-xlsx.git nodejs-xlsx .gitmodules可以看到新增了以下内容 123[submodule &quot;nodejs-xlsx&quot;] path = nodejs-xlsx url = https://github.com/ICELI/nodejs-xlsx.git 下载包含子模块的项目后， 1git clone https://github.com/ICELI/nodejs.git 先git submodule init，再git submodule update更新子模块代码 在其它地方对子模块改动后，本地仓库怎么同步呢 先重复以上步骤 在子模块git merge origin/master(也可以是其他分支) 在父模块git add .（可通过git status查看改动，选择上面的子模块改动） 在父模块git commit -m &#39;update submodule&#39; 在父模块git pull（提交子模块的改动） 这样我们既可以通过小项目去维护代码，又可以通过一个大的父项目去查看和维护整个项目]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue2源码：响应式原理]]></title>
      <url>%2F2017%2F05%2F06%2Fvue2%2FVue2-reactivity%2F</url>
      <content type="text"><![CDATA[把一个普通 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。Object.defineProperty 是仅 ES5 支持，且无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。 每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。 src/core/instance/state.js]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue2源码：准备]]></title>
      <url>%2F2017%2F05%2F05%2Fvue2%2FVue2-flow%2F</url>
      <content type="text"><![CDATA[因为vue2使用了flow进行静态代码检查，rollup进行代码构建，所以在进行源码阅读之前，还需要补充下这几块知识 flow https://flow.org/ http://www.imooc.com/m/wap/article/detail.html?aid=15855 rollup Tree-shaking, 对于lib而言 rollup更适合用。 用 webpack 打包，还是会自带一个小型的动态 module 加载机制，并且每个文件是包在一个模块函数里的。rollup 打包通过重命名 import binding 直接把所有文件的函数都放在同一个函数体里面… 所以最终出来的文件会小一些，并且初始化快个十几毫秒的样子。–尤小右 官网 https://rollupjs.org/ API https://github.com/rollup/rollup/wiki/JavaScript-API 尤小右 https://www.zhihu.com/question/37861778/answer/73847503 小爵 https://zhuanlan.zhihu.com/p/25276769 API 分类 Global Config Global API Options Data DOM Lifecycle Hooks Assets composition Misc Instance Properties Instance Methods Data //stateMixin src/core/instance/state.js Events //eventMixin src/core/instance/events.js Lifecycle //除了$mount方法被分到runtime.js中定义，最终还是调用的mountComponent Directives Special Attributes Built-In Component VNode Interface Server-side Rendering 阅读源码时，可以看到这些API是在哪个阶段定义的，代码看完你找到了吗？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue2源码]]></title>
      <url>%2F2017%2F05%2F04%2Fvue2%2FVue2%2F</url>
      <content type="text"><![CDATA[版本：v2.3.0 ，先看这里CONTRIBUTING flow 进行静态代码检查 observer Vue 双向数据绑定实现 snabbdom Virtual Dom compiler render function SSR rollup vue学习开篇，学习计划]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angularjs $location.search实现URL保存搜索条件]]></title>
      <url>%2F2017%2F04%2F12%2Fangular.js%2Furl%2F</url>
      <content type="text"><![CDATA[当查询条件较少且固定时，推荐使用路由方式比较简便。当搜索条件多且不定的情况下，可使用该方法。 页面刷新初始化一次查询initSearch() #L37 搜索和浏览器前进后退的查询都用$locationChangeSuccess事件，回调执行 initSearch() #L16 搜索的$locationChangeSuccess事件由执行$location.search(option)方法触发#L23 我们把查询事件的异常处理提取到jmSearch服务当中，该服务由jmui管理 需要保存搜索条件的页面在controller中注入jmSearch服务 #L6 jmSearch需要传入当前$scope和查询的方法initSearch #L39 页面路由需配置reloadOnSearch: false, 防止刷新页面 search.js#L6 参考：ng-seed /search模块]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[V2FE]]></title>
      <url>%2F2017%2F04%2F05%2FV2FE%2F</url>
      <content type="text"><![CDATA[6年前端路，全站flash美工-&gt;前端开发-&gt;高级前端开发-&gt;前端主管-&gt;前端项目经理-&gt;前端架构师，title一直在变，可我始终是一名前端。 小马过河 - 他人的经验永远不可能直接用于自己，前端知识需要自己去总结归纳。]]></content>
    </entry>

    
  
  
</search>
